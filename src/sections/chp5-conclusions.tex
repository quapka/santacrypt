\chapter{Conclusion}
        In the very last section we will take a moment to reflect on the JavaCard Vulnerability Scanner framework and try to have a peek into its future. Then we will close off this text with the summary of the security of JavaCard Virtual Machine.

        \section{The future of JavaCard Vulnerability Scanner}

        As observed in the previous results and in our own as well it is apparent that different JavaCards implement the on-card byte code verifiers and run-time checks differently. This is not surprising, considering that the complete JavaCard RE is left to the JavaCard vendors to be implemented and already~\cite{Mostowski07testingthe} showed that the specifications are not always followed completely or can be ambiguous. Since some cards perform better it suggests that the vendors could learn from each other in order to improve the JavaCard platform. From this perspective we see potential in a project like JavaCard Vulnerability Scanner that could help bringing more transparency into the security of JavaCards. Our tool is capable to test a JavaCard across various SDKs and attacks and can gather results similar to~\ref{tab:results-overview}.

        As stated previously, the JavaCard Vulnerability Scanner is still a prototype. It can serve as a base for future analysis of JavaCards, because it can be already used for executing regular applets and not only testing logical attacks. The implementation was done in such a way that it allows to switch different parts or extend another one. In case the JavaCard community will find JavaCard Vulnerability Scanner useful the web application can be moved into a separate project and be hosted as a public service that would allow not only researchers to submit or verify their own results from JavaCard Vulnerability Scanner. Such public database could speed up the development of the security of the JavaCard Virtual Machine JavaCard Runtime Environment and also help to make the applications developed for this platform overall more secure.

        For now, however, we invite other developers and researchers to use this tool locally, find its shortcomings or opportunities for new features and submit both at \url{\githuburl}. It would only be for the better if academic results would affect the non-academic world and vice-versa. Tools developed just for the sake of satisfying formal academic requirements are bound to die out quickly.

        According to Oracle~\cite{oraclehome} more than 9 billion Java Card enabled devices have been shipped since 1998 and the number keeps rising. For several years it is possible to buy open JavaCard that allow installation of new custom applets and therefore we can expect more applications emerging on the JavaCard platform.
        % Java Card platform and the its development still kept propriatery.
        % However, it is a platform deployed all over the world in billions of units and this number keeps raising.
        And as examples from other fields of information technology show, there will hardly ever come a struggle to have a particular platform \textit{too much secure}. Rather, every step into making the security assessment of a given platform simpler to perform and more thorough is welcomed. The author would be honoured, if this tool would help to pave the way alongside the projects like JCAlgTest and ECTester (and other), towards more transparent and secure JavaCard platform.

        \section{Possibilities for future attacks}

        Throughout the many attacks the reocurring problem is type confusion or insufficient type checking. What is often mentioned when discussing additional run-time checks are the limited resources of JavaCard. However, as observed in~\cite{se:oracle:part1, se:oracle:part2, se:oracle:part3} the input value checking is not done for \textit{some} methods properly even in \texttt{cref}. The reference implementation is not limited in its resources as it can run on a regular computer. Testing on real JavaCards is not much cost effective, as the JavaCards can get damaged, blocked, locked or render unsuable in other way beyond repair. It happened to us during the development of \javus for at least three JavaCards. On one hand, we have developed JavaCard Vulnerability Scanner to bring testing to \textit{real} JavaCards to bigger audience and to gather results from more JavaCards than individual researchers is able. Testing is often most helpful on the real system. On the other hand, due to the cost effectivness it is good to see that vulnerabilities discovered in the reference implementation do affect real JavaCard and therefore the analysis does help to improve the overall security of the platform.


        The vulnerabilites presented in~\ref{sec:related-work} are often elaborate as is visible from the common step of CAP file alteration or first discovering e.g. array metadata and consequently using them in later stages of the attack. We do not know, what was the approach of Security Explorations, that they discovered so many vulnerabilites, maybe they have used more automated and therefore possible thorough anlaysis of \texttt{cref}. Nevertheless, using \texttt{cref} for analysis brings fruits.


        Further, our approach~\ref{subsec:onofffuzzing} to on-card vs. off-card BCV fuzzing has yield preliminary results. We have not seen fuzzing used for testing JavaCard security. At first sight JavaCard does not seem to be a great platform for fuzz testing, because it relies on generating and analyzing huge number of inputs/outputs to the targetted program. We have observed, that the part of current implementation of JavaCard Vulnerability Scanner responsible for communicating with JavaCard is the bottleneck. Fuzz testing can be done in the way it was proposed in~\ref{subsec:onofffuzzing}, but it is expected to be slow. The author thinks, that maybe the whole process could be sped up significantly by first fuzzing the JavaCard RE Reference Implementation and use only subset of those inputs then on real JavaCards. Generating interesting inputs to such fuzz testing could be hard, because the reference implementation can just keep failing due to completely random inputs, but the analysis of the crash can be more elaborate than simply noting a crash of an application (as it is often enough for other fuzz testing). Because \texttt{cref} is started as a process on a standard computer an elaborate monitoring techniques could be used --- the reeader can imagine \textit{fuzzing} \texttt{cref} and making snapshots of the memory after each run. The differences between the snapshots could yield which inputs are more probably to cause a real issue. The input to fuzz testing can be fixed in the bytes regarding the installation of some applet and only subsequent APDUs can be fuzzed.         % from the many attacks, that we have studied we see few take-aways. it is a positive news, that none of the tested cards were vulnerable to the old attack \texttt{transaction_confusion}~\cite{}.

        % However, the attack was using type confusion and several new vulnerabilites exploiting slightly different type confusion on the level of byte code instructions and API methods have been discovered recently (little more than a year ago~\cite{se:gemalto:part1, se:gemalto:part
